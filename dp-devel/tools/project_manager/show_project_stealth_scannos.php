<?php
$relPath="./../../pinc/";
include_once($relPath.'site_vars.php');
include_once($relPath.'dp_main.inc');
include_once($relPath.'project_states.inc');
include_once($relPath.'stages.inc');
include_once($relPath.'Project.inc');
include_once($relPath.'wordcheck_engine.inc');
include_once($relPath.'theme.inc');
include_once('./post_files.inc');
include_once('./word_freq_table.inc');

set_time_limit(0); // no time limit

$projectid = $_REQUEST["projectid"];

enforce_edit_authorization($projectid);

// $format determins what is presented from this page:
//   'html' - page is rendered with frequencies included
//   'file' - all words and frequencies are presented as a
//            downloaded file
// 'update' - update the list
$format = array_get($_REQUEST, "format", "html");

if($format=="update") {
    $postedWords = parse_posted_words($_POST);

    $words = load_project_bad_words($projectid);
    $words = array_merge($words,$postedWords);
    save_project_bad_words($projectid,$words);

    $format="html";
}

$title = _("Candidates for project's Bad Words List from round compare");
$page_text = _("Displayed below are the words from this project that are likely scannos based on text comparisons.");
$page_text .= " ";
$page_text .= _("The results list was generated by comparing the raw OCR text and the most recent text of each page. Words that were changed between the two that WordCheck would otherwise not flag, that are not already on the site or project word lists, and still appear in the latest copy of the text are included in the results. The results list also shows the corrected text for that word.");

list($possible_scannos_w_freq,$messages,$possible_scannos) = _get_word_list($projectid);

if($format == "file") {
    $filename="${projectid}_project_scannos.txt";
    header("Content-type: text/plain");
    header('Content-Disposition: attachment; filename="' . $filename . '"');
    // The cache-control and pragma is a hack for IE not accepting filenames
    header('Cache-Control: must-revalidate, post-check=0, pre-check=0');
    header('Pragma: public');

    echo $title . "\r\n";
    echo sprintf(_("Project: %s"),get_project_name($projectid)) . "\r\n";
    echo "\r\n";
    echo strip_tags($page_text) . "\r\n";
    echo "\r\n";
    echo_page_instruction_text( "bad", $format );
    echo "\r\n";
    echo_download_text( $projectid, $format );
    echo "\r\n";
    echo _("Format: [word] - [frequency in text]") . "\r\n";
    echo "\r\n";

    foreach( $possible_scannos_w_freq as $word => $freq)
        echo "$word - $freq\r\n";

    // we're done here, exit
    exit;
}

$no_stats=1;
theme($title,"header");
echo_page_header($title,$projectid);

// how many instances (ie: frequency sections) are there?
$instances=1;
// what are the cutoff options?
$cutoffOptions = array(1,2,3,4,5,10,25,50);
// what is the intial cutoff frequecny?
$initialFreq=getInitialCutoff(5,$cutoffOptions,$possible_scannos_w_freq);

// echo page support text, like JS and stylesheets
echo_cutoff_script($cutoffOptions,$instances);

echo_word_freq_style();

echo "<p>$page_text</p>";

echo_page_instruction_text( "bad", $format );

echo_any_warnings_errors( $messages );

echo_download_text( $projectid, $format );

echo_cutoff_text( $initialFreq,$cutoffOptions );

$context_array = build_context_array_links($possible_scannos_w_freq,$projectid);
$context_array["[[TITLE]]"]=_("Show Context");
$possible_scannos["[[TITLE]]"]=_("Corrected Word");
$possible_scannos["[[CLASS]]"]="mono";

$word_checkbox = build_checkbox_array($possible_scannos_w_freq);

echo_checkbox_selects(count($possible_scannos_w_freq));

$checkbox_form["projectid"]=$projectid;
$checkbox_form["freqCutoff"]=$freqCutoff;
echo_checkbox_form_start($checkbox_form);
echo_checkbox_form_submit(_("Add selected words to Bad Words List"));

printTableFrequencies($initialFreq,$cutoffOptions,$possible_scannos_w_freq,$instances--,array($context_array,$possible_scannos), $word_checkbox);

echo_checkbox_form_submit(_("Add selected words to Bad Words List"));
echo_checkbox_form_end();

theme('','footer');


//---------------------------------------------------------------------------
// supporting page functions

function _get_word_list($projectid) {
    global $aspell_temp_dir;
    global $word_pattern;

    $ocr_filename = "$aspell_temp_dir/${projectid}_ocr.txt";
    $latest_filename = "$aspell_temp_dir/${projectid}_latest.txt";

    $messages = array();

    // get the OCR text
    $pages_res = page_info_query($projectid,'[OCR]','LE');
    file_put_contents($ocr_filename, get_page_texts( $pages_res ));

    // get the latest project text of all pages up to last possible round
    $last_possible_round = get_Round_for_round_number(MAX_NUM_PAGE_EDITING_ROUNDS);
    $pages_res = page_info_query($projectid,$last_possible_round->id,'LE');
    $all_page_text = get_page_texts( $pages_res );
    file_put_contents($latest_filename, $all_page_text);

    $all_words_w_freq = get_distinct_words_in_text( $all_page_text );
    // clean up unused variables
    unset($all_page_text);

    $possible_scannos_w_correction = array();

    $wdiff_output = `wdiff -3 $ocr_filename $latest_filename`;
    $separater = '======================================================================';
    $wdiff_segments = explode($separater,$wdiff_output);

    // clean up the temporary files
    if(is_file($ocr_filename)) {
        unlink($ocr_filename);
    }
    if(is_file($latest_filename)) {
        unlink($latest_filename);
    }

    // process wdiff output
    foreach ($wdiff_segments as $segment) {
        // note that we're handling the case where two adjacent
        // words are updated
        $ocr_words=$latest_words=array();

        // pull out the original word(s)
        if(preg_match("/\[-(.*?)-\]/",$segment,$matches)) {
            $ocr_words=get_all_words_in_text($matches[1]);
        }

        // pull out the replacement(s)
        if(preg_match("/{\+(.*?)\+}/",$segment,$matches)) {
            $latest_words=get_all_words_in_text($matches[1]);
        }

        // if the number of words isn't the same between the two
        // bail since we don't handle that case yet
        if(count($ocr_words) != count($latest_words)) continue;

        for($index=0; $index<count($ocr_words); $index++) {
            $ocr_word=$ocr_words[$index];
            $latest_word=$latest_words[$index];

            // if the words are the same or one of them empty, skip it
            if(($ocr_word == $latest_word) || empty($ocr_word) || empty($latest_word)) continue;

            $possible_scannos_w_correction[$ocr_word]=$latest_word;
        }
    }

    $possible_scannos = array_keys($possible_scannos_w_correction);

    // create a string of words to run through WordCheck
    $text_to_check = implode(" ",$possible_scannos);

    // run the list through WordCheck to see which it would flag
    list($possible_scannos_via_wordcheck,$languages,$messages) =
        get_bad_words_for_text($text_to_check,$projectid,'all','',array(),'FREQS');

    // load project languages
    $languages = array_unique(array_values(get_project_languages($projectid)));

    // load site word lists for project languages
    $site_bad_words = array();
    foreach ( $languages as $language ) {
        $langcode3 = langcode3_for_langname( $language );
        $site_bad_words = array_merge($site_bad_words, load_site_bad_words($langcode3));
    }
    $site_bad_words = array_unique($site_bad_words);

    // load the project bad words
    $project_bad_words = load_project_bad_words($projectid);

    // remove words that WordCheck would flag
    $possible_scannos = array_diff($possible_scannos, array_flip($possible_scannos_via_wordcheck));

    // remove any scannos already on the site and project bad word lists
    $possible_scannos = array_diff($possible_scannos, $site_bad_words, $project_bad_words);

    // $possible_scannos doesn't have frequency info, 
    // so start with the info in $all_words_w_freq,
    // and extract the items where the key matches a key in $possible_scannos
    $possible_scannos_w_freq = array_intersect_key( $all_words_w_freq, array_flip($possible_scannos));

    // multisort screws up all-numeric words so we need to preprocess first
    prep_numeric_keys_for_multisort( $possible_scannos_w_freq );

    // sort the list by frequency, then by word
    array_multisort( array_values( $possible_scannos_w_freq ), SORT_DESC, array_map( 'strtolower', array_keys( $possible_scannos_w_freq )), SORT_ASC, $possible_scannos_w_freq);

    return array($possible_scannos_w_freq,$messages,$possible_scannos_w_correction);
}

// vim: sw=4 ts=4 expandtab
?>
